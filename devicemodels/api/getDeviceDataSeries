/**
 * Get historical data of a given id
 * @param {String} id: the identifier of the device to load
 * @param {String} field: optional, if defined, script only returns the latest value of this field in a device
 * @param {Number} page: optional, if defined, instructs to load the data series documents at the given page. Defaults to 1
 * @return {Object} [{field:value, etc.}, {field:value, etc.}, ...}
 */ 

var config =  require("../config");
var DEFAULT_CHANNEL = "responseChannel";

try {
  
  require("/modules/framr/Framr").init(this, {classPath: "modules/;"});
  import("devicemodels.demoApp.model.Car");
  import("agnes.VersionableDeviceRepositoryAdaptor");

   //check search criteria
  var params = {};
  if(request.body != null){
    params = request.body;
  }else if(request.parameters.body){
    params = request.parameters.body;
  }else {
    params = request.parameters;
  }
  
  if(typeof params == 'string' && params != null){
    try{
      params = JSON.parse(params);   
    }catch(e){
      return "INVALID OR MISSING PARAMETER";
    }
  }

  var id = params.id;
  if (!id){
    return "MISSING 'id' PARAMETER";;
  }

  var field = params.field;

  /**
   * Load device data series
   */
  var adaptor = new VersionableDeviceRepositoryAdaptor();
  var deviceDataSeries = adaptor.loadDataSeries(id);
  
  /**
   * If field is mentioned, return data series for that fied only + publish over channel
   */
  if (field) {
   
    var dataSeries = [];
    var dev = {
      id: id
    };
    
    for (var i = 0; deviceDataSeries && i < deviceDataSeries.length; i++) {
      
      var deviceData = deviceDataSeries[i];
      var output = {};
      output["time"] = deviceData.lastModifiedDate;
      output[field] = deviceData[field];
      dataSeries.push(output);        
    }
    
    dev["result"] = dataSeries;    
    publishUpdate(dev);
    return dev;
  }
 
  /*
   * If no field is mentioned, returned data series for all fields + publish
   */
  var output = {};
  for (var i = 0; deviceDataSeries && i < deviceDataSeries.length; i++) {
  
    var deviceData = deviceDataSeries[i]; 
    var time = deviceData.lastModifiedDate;
    for (var key in deviceData) {
      
      if (["key", "rootkey", "lastModifiedDate",  "creator", "lastModifiedBy", "creationDate", "cls", "versionNumber", "meta.types"].indexOf(key) < 0) {
        
        if (!output[key]){
          output[key] = [];
        }else {
          
          var obj = {};
          obj.time = time;
          obj[key] = deviceData[key];
          output[key].push(obj);        
        }
      }      
    }
  }
  
  for (var key in output) {
  
    var dev = {};
    dev.id = id,
    dev[key] = output[key];    
    publishUpdate(dev);
  }
  
  return output;
}catch(exception){
  
  var log = require("log"); 
  log.setLevel("info");
  log.error("Exception occured while invoking devicemodels/api/getDeviceDataSeries:\n " + JSON.stringify(exception));
  return {};
}

function publishUpdate(device) {
  
  /**
   * message = {id: deviceid.field, result: }
   * gauge, speedo, odo: result = value
   * charts (line, bar, ): result = [y, x, x]
   */
  
  var channel = config && config.channel ? config.channel : DEFAULT_UPDATE_CHANNEL;
  // var model = modelModule[device.cls];
  for (var key in device) {
    
    // var widgetObj = model ? model.attributes[key] : null;
    // var widgetType = widgetObj ? widgetObj.type : null;    
    if (["cls", "id", "vin", "make", "model", "year"].indexOf(key) < 0) {
      
      var msg = {};
      msg["id"] = ""+ device.id + "." + key;
      msg["result"] = device[key]; 
      publish(channel, JSON.stringify(msg));
    }    
  }  
}
